# Project Structure

```
djangopackages/
├── __init__.py
├── manage.py
├── settings.py
├── urls.py
├── conftest.py
├── apiv3/
│   ├── __init__.py
│   ├── resources.py
│   ├── urls.py
│   └── views.py
├── apiv4/
│   ├── __init__.py
│   ├── admin.py
│   ├── mixins.py
│   ├── serializers.py
│   ├── urls.py
│   └── viewsets.py
├── core/
│   ├── __init__.py
│   ├── models.py
│   └── utils.py
├── grid/
│   ├── __init__.py
│   ├── admin.py
│   ├── forms.py
│   ├── models.py
│   ├── urls.py
│   ├── views.py
│   └── tests/
│       ├── test_views.py
│       └── test_models.py
├── homepage/
│   ├── __init__.py
│   ├── models.py
│   └── views.py
├── package/
│   ├── __init__.py
│   ├── admin.py
│   ├── forms.py
│   ├── managers.py
│   ├── models.py
│   ├── signals.py
│   ├── urls.py
│   ├── utils.py
│   ├── views.py
│   └── tests/
│       ├── test_views.py
│       └── test_models.py
├── profiles/
│   ├── __init__.py
│   └── models.py
├── searchv2/
│   ├── __init__.py
│   ├── models.py
│   ├── utils.py
│   └── views.py
└── templates/
```

# Relevant source files

## apiv4/viewsets.py
```python
from rest_framework import mixins, viewsets
from rest_framework.response import Response

from grid.models import Grid
from package.models import Category, Package
from searchv2.models import SearchV2
from searchv2.views import search_function

from .mixins import MultiLookupFieldMixin
from .serializers import (
    CategorySerializer,
    GridSerializer,
    PackageSerializer,
    SearchV2Serializer,
)


class SearchV2ViewSet(mixins.ListModelMixin, viewsets.GenericViewSet):
    """Accepts a 'q' GET parameter. Results are currently sorted only by
    their weight.
    """

    serializer_class = SearchV2Serializer
    queryset = SearchV2.objects.all()

    def list(self, request):
        qr = request.GET.get("q", "")
        queryset = search_function(qr)[:20]
        serializer = SearchV2Serializer(queryset, many=True)
        return Response(serializer.data)


class PackageViewSet(MultiLookupFieldMixin, viewsets.ReadOnlyModelViewSet):
    """
    API endpoint that allows packages to be viewed or edited.
    """

    queryset = Package.objects.all().order_by("-id")
    serializer_class = PackageSerializer
    paginate_by = 20


class GridViewSet(MultiLookupFieldMixin, viewsets.ReadOnlyModelViewSet):
    queryset = Grid.objects.all().order_by("-id")
    serializer_class = GridSerializer
    paginate_by = 20


class CategoryViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Category.objects.all().order_by("-id")
    serializer_class = CategorySerializer
    paginate_by = 20

```

## apiv4/serializers.py
```python
import emoji
from django.core.exceptions import ImproperlyConfigured
from django.urls import NoReverseMatch
from rest_framework import relations, serializers
from rest_framework.reverse import reverse

from grid.models import Grid
from package.models import Category, Package
from searchv2.models import SearchV2


class GridSerializer(serializers.ModelSerializer):
    packages = serializers.HyperlinkedRelatedField(
        many=True,
        view_name="apiv4:package-detail",
        read_only=True,
        lookup_url_kwarg="pk_or_slug",
    )

    class Meta:
        fields = [
            "id",
            "title",
            "slug",
            "description",
            "is_locked",
            "packages",
            "header",
            "created",
            "modified",
        ]
        model = Grid


class PackageSerializer(serializers.HyperlinkedModelSerializer):
    # 'Source' is attached to the model attribute
    participants = serializers.ListField(source="participant_list")
    commits_over_52 = serializers.ListField(source="commits_over_52_listed")
    grids = serializers.HyperlinkedRelatedField(
        many=True,
        view_name="apiv4:grid-detail",
        read_only=True,
        lookup_url_kwarg="pk_or_slug",
    )
    category = serializers.HyperlinkedRelatedField(
        view_name="apiv4:category-detail", read_only=True
    )

    class Meta:
        model = Package
        fields = (
            "category",
            "grids",
            "id",
            "title",
            "slug",
            "last_updated",
            "last_fetched",
            "repo_url",
            "pypi_version",
            "created",
            "modified",
            "repo_forks",
            "repo_description",
            "pypi_url",
            "documentation_url",
            "repo_watchers",
            "commits_over_52",
            "participants",
        )


class SearchV2Hyperlink(serializers.HyperlinkedRelatedField):
    view_name = "package-detail"

    def get_url(self, obj, view_name, request, format):
        url_kwargs = {"organization_slug": obj.organization.slug, "customer_pk": obj.pk}
        return reverse(view_name, url_kwargs, request=request, format=format)

    def get_object(self, view_name, view_args, view_kwargs):
        lookup_kwargs = {
            "organization__slug": view_kwargs["organization_slug"],
            "pk": view_kwargs["customer_pk"],
        }
        return self.get_queryset().get(**lookup_kwargs)


class HyperlinkFeld(serializers.HyperlinkedRelatedField):
    lookup_field = "pk"

    def get_url(self, obj, view_name):
        """
        Given an object, return the URL that hyperlinks to the object.
        May raise a `NoReverseMatch` if the `view_name` and `lookup_field`
        attributes are not configured to correctly match the URL conf.
        """
        # Unsaved objects will not yet have a valid URL.
        if hasattr(obj, "pk") and obj.pk is None:
            return None
        kwargs = {"pk": 1}
        return reverse(view_name, kwargs=kwargs)

    def to_representation(self, value):
        self.view_name = f"apiv4:{value.item_type}-detail"

        try:
            url = self.get_url(value, self.view_name)
        except NoReverseMatch:
            msg = (
                "Could not resolve URL for hyperlinked relationship using "
                'view name "%s". You may have failed to include the related '
                "model in your API, or incorrectly configured the "
                "`lookup_field` attribute on this field."
            )
            if value in ("", None):
                value_string = {"": "the empty string", None: "None"}[value]
                msg += (
                    " WARNING: The value of the field on the model instance "
                    "was %s, which may be why it didn't match any "
                    "entries in your URL conf." % value_string
                )
            raise ImproperlyConfigured(msg % self.view_name)

        if url is None:
            return None

        return relations.Hyperlink(url, str(value))


class SearchV2Serializer(serializers.ModelSerializer):
    # resource_uri = HyperlinkFeld(source='_self')
    description = serializers.SerializerMethodField()
    title = serializers.SerializerMethodField()

    class Meta:
        model = SearchV2
        exclude = [
            "id",
        ]

    def get_description(self, obj):
        return emoji.emojize(obj.description)

    def get_title(self, obj):
        return emoji.emojize(obj.title)


class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        fields = [
            "id",
            "title",
            "slug",
            "description",
            "title_plural",
            "show_pypi",
            "created",
            "modified",
        ]
        model = Category

```

## apiv4/urls.py
```python
from rest_framework import routers

from .viewsets import CategoryViewSet, GridViewSet, PackageViewSet, SearchV2ViewSet

app_name = "apiv4"

router = routers.DefaultRouter()
router.register(r"packages", PackageViewSet)
router.register(r"search", SearchV2ViewSet)
router.register(r"grids", GridViewSet)
router.register(r"categories", CategoryViewSet)

urlpatterns = router.urls

```

## apiv4/mixins.py
```python
class MultiLookupFieldMixin:
    lookup_url_kwarg = "pk_or_slug"

    @property
    def lookup_field(self):
        assert self.lookup_url_kwarg, "The `lookup_url_kwarg` field is required."

        obj_ident = self.kwargs[self.lookup_url_kwarg]
        return "pk" if obj_ident.isdigit() else "slug"

```

## homepage/views.py
```python
from datetime import date

from django.contrib.auth.models import User
from django.core.cache import cache
from django.db.models import Count, Q
from django.http import HttpResponse
from django.shortcuts import render
from django.views.generic import TemplateView

from grid.models import Grid
from homepage.models import Gotw, Dpotw, PSA
from package.models import Category, Commit, Package, Version
from products.models import Product, Release


class OpenView(TemplateView):
    template_name = "pages/open.html"

    def get_context_data(self, **kwargs):
        context_data = super().get_context_data(**kwargs)
        classifiers = {
            "total_django_2_2": "Framework :: Django :: 2.2",
            "total_django_3_0": "Framework :: Django :: 3.0",
            "total_django_3_1": "Framework :: Django :: 3.1",
            "total_django_3_2": "Framework :: Django :: 3.2",
            "total_django_4_0": "Framework :: Django :: 4.0",
            "total_django_4_1": "Framework :: Django :: 4.1",
            "total_django_4_2": "Framework :: Django :: 4.2",
            "total_django_5_0": "Framework :: Django :: 5.0",
            "total_django_5_1": "Framework :: Django :: 5.1",
            "total_django_5_2": "Framework :: Django :: 5.2",
            "total_django_6_0": "Framework :: Django :: 6.0",
            "total_python_2_7": "Programming Language :: Python :: 2.7",
            "total_python_3": "Programming Language :: Python :: 3",
            "total_python_3_6": "Programming Language :: Python :: 3.6",
            "total_python_3_7": "Programming Language :: Python :: 3.7",
            "total_python_3_8": "Programming Language :: Python :: 3.8",
            "total_python_3_9": "Programming Language :: Python :: 3.9",
            "total_python_3_10": "Programming Language :: Python :: 3.10",
            "total_python_3_11": "Programming Language :: Python :: 3.11",
            "total_python_3_12": "Programming Language :: Python :: 3.12",
            "total_python_3_13": "Programming Language :: Python :: 3.13",
            "total_python_3_14": "Programming Language :: Python :: 3.14",
            "total_python_3_15": "Programming Language :: Python :: 3.15",
        }
        vcs_providers = {
            "repos_bitbucket": "bitbucket.org",
            "repos_github": "github.com",
            "repos_gitlab": "gitlab.com",
        }

        active_package_aggregations = Package.objects.active().aggregate(
            # Total package count for each VCS provider
            **{
                key: Count("pk", filter=Q(repo_url__contains=value))
                for key, value in vcs_providers.items()
            },
            # Total package count for each classifier
            **{
                key: Count("pk", filter=Q(pypi_classifiers__contains=[value]))
                for key, value in classifiers.items()
            },
        )
        context_data.update(active_package_aggregations)

        all_package_aggregations = Package.objects.aggregate(
            # Total package Count
            total_packages=Count("pk"),
            # Total archived package Count
            archive_packages=Count("pk", filter=~Q(date_repo_archived__isnull=True)),
            # Total deprecated package Count
            deprecated_packages=Count(
                "pk",
                filter=~Q(date_deprecated__isnull=True, deprecated_by__isnull=True),
            ),
        )
        context_data.update(all_package_aggregations)

        context_data["categories"] = Package.objects.active().aggregate(
            **{
                title: Count("pk", filter=Q(category_id=pk))
                for pk, title in Category.objects.values_list("pk", "slug")
            }
        )

        top_grid_list = (
            Grid.objects.all()
            .annotate(num_packages=Count("packages"))
            .filter(num_packages__gte=25)
            .order_by("-num_packages")[0:100]
        )
        top_user_list = (
            User.objects.all()
            .annotate(num_packages=Count("creator"))
            .filter(num_packages__gt=10)
            .order_by("-num_packages")
        )

        context_data.update(
            {
                "top_grid_list": top_grid_list[0:100],
                "top_user_list": top_user_list[0:100],
                "total_categories": Category.objects.count(),
                "total_commits": Commit.objects.count(),
                "total_grids": Grid.objects.count(),
                "total_users": User.objects.count(),
                "total_versions": Version.objects.count(),
            }
        )

        return context_data


class ReadinessView(TemplateView):
    template_name = "readiness/index.html"

    def get_context_data(self, **kwargs):
        context_data = super().get_context_data(**kwargs)

        # Django Releases
        django_releases = Release.objects.filter(product__slug="django").order_by(
            "-release"
        )
        context_data["django_releases"] = django_releases

        # Python Releases
        python_releases = Release.objects.filter(product__slug="python").order_by(
            "-release"
        )
        context_data["python_releases"] = python_releases

        # Wagtail Releases
        wagtail_releases = Release.objects.filter(product__slug="wagtail").order_by(
            "-release"
        )
        context_data["wagtail_releases"] = wagtail_releases

        return context_data


class ReadinessDetailView(TemplateView):
    template_name = "readiness/readiness_detail.html"

    def get_context_data(self, **kwargs):
        context_data = super().get_context_data(**kwargs)

        limit = 120
        context_data["limit"] = limit

        product_slug = self.kwargs.get("product_slug")
        product = Product.objects.get(slug=product_slug)
        context_data["product"] = product

        cycle = self.kwargs.get("cycle")
        context_data["cycle"] = cycle

        release = Release.objects.get(product=product, cycle=cycle)
        context_data["release"] = release

        if product_slug == "django":
            pypi_classifier = ["Framework :: Django"]
            ready_condition = f"Framework :: Django :: {cycle}"

        elif product_slug == "python":
            pypi_classifier = [
                "Programming Language :: Python",
                "Programming Language :: Python :: 3",
            ]
            ready_condition = f"Programming Language :: Python :: {cycle}"

        elif product_slug == "wagtail":
            pypi_classifier = ["Framework :: Wagtail"]
            ready_condition = f"Framework :: Wagtail :: {cycle}"

        else:
            pypi_classifier = ["None Pizza :: Left Beef"]
            ready_condition = "None Pizza"

        context_data["ready_condition"] = ready_condition

        packages = (
            Package.objects.only(
                "title", "pypi_downloads", "pypi_classifiers", "slug", "repo_watchers"
            )
            .filter(pypi_classifiers__contains=pypi_classifier)
            .exclude(
                Q(title="django") | Q(slug="django")
            )  # TODO: might be worth re-addressing...
            .order_by("-repo_watchers", "-pypi_downloads")[:limit]
        )

        packages = [package.__dict__ for package in packages]
        for package in packages:
            classifiers = [
                classifier
                for classifier in package["pypi_classifiers"]
                if classifier.startswith(pypi_classifier[0])
            ]

            if ready_condition in classifiers:
                package["is_ready"] = "yes"

            elif len(classifiers) > 1:
                package["is_ready"] = "no"

            else:
                package["is_ready"] = "maybe"

        context_data["cycle"] = cycle
        context_data["packages"] = packages
        context_data["product_slug"] = product_slug.title()

        return context_data


def homepage(request, template_name="homepage.

# ... (truncated for brevity)
```

## package/models.py
```python
import json
import math
from datetime import timedelta
import requests
from dateutil import relativedelta
from django.conf import settings
from django.contrib.auth.models import User

# from django.contrib.postgres.fields import ArrayField
from django.core.cache import cache
from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.db.models.constraints import UniqueConstraint
from django.urls import reverse
from django.utils import timezone
from django.utils.timezone import now
from django.utils.translation import gettext_lazy as _
from django_better_admin_arrayfield.models.fields import ArrayField
from looseversion import LooseVersion
from packaging.specifiers import SpecifierSet
from requests.exceptions import HTTPError
from rich import print

from core.models import BaseModel
from core.utils import PackageStatus, status_choices_switch
from package.managers import PackageManager
from package.repos import get_repo_for_repo_url
from package.signals import signal_fetch_latest_metadata
from package.utils import get_pypi_version, get_version, normalize_license

repo_url_help_text = settings.PACKAGINATOR_HELP_TEXT["REPO_URL"]
pypi_url_help_text = settings.PACKAGINATOR_HELP_TEXT["PYPI_URL"]


class RepoHost(models.TextChoices):
    AUTO_DETECT = "", _("Auto-detect")
    BITBUCKET = "bitbucket", _("Bitbucket")
    GITHUB = "github", _("GitHub")
    GITLAB = "gitlab", _("GitLab")
    CODEBERG = "codeberg", _("Codeberg")
    FORGEJO = "forgejo", _("Forgejo")


class NoPyPiVersionFound(Exception):
    pass


class Category(BaseModel):
    title = models.CharField(_("Title"), max_length=50)
    slug = models.SlugField(_("slug"))
    description = models.TextField(_("description"), blank=True)
    title_plural = models.CharField(_("Title Plural"), max_length=50, blank=True)
    show_pypi = models.BooleanField(_("Show pypi stats & version"), default=True)

    class Meta:
        ordering = ["title"]
        verbose_name_plural = "Categories"

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse("category", args=[self.slug])


class Package(BaseModel):
    title = models.CharField(_("Title"), max_length=100)
    slug = models.SlugField(
        _("Slug"),
        help_text="Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens. Values will be converted to lowercase.",
        unique=True,
    )
    category = models.ForeignKey(
        Category, verbose_name="Installation", on_delete=models.PROTECT
    )
    repo_description = models.TextField(
        _("Repo Description"), blank=True, max_length=500
    )
    repo_url = models.URLField(
        _("repo URL"), help_text=repo_url_help_text, blank=True, unique=True
    )
    repo_host = models.CharField(
        _("Repo host"),
        max_length=30,
        choices=RepoHost,
        blank=True,
        default=RepoHost.AUTO_DETECT,
        help_text=_(
            "Select the hosting service when auto-detection cannot determine it."
        ),
    )
    repo_watchers = models.IntegerField(_("Stars"), default=0)
    repo_forks = models.IntegerField(_("repo forks"), default=0)
    pypi_url = models.CharField(
        _("PyPI slug"),
        max_length=255,
        help_text=pypi_url_help_text,
        blank=True,
        default="",
    )
    pypi_downloads = models.IntegerField(_("PyPI downloads"), default=0)
    pypi_classifiers = ArrayField(
        models.CharField(max_length=100), blank=True, null=True
    )
    pypi_info = models.JSONField(blank=True, null=True)
    pypi_license = models.CharField(
        _("PyPI License"), max_length=100, blank=True, null=True
    )
    pypi_licenses = ArrayField(models.CharField(max_length=100), blank=True, null=True)
    pypi_requires_python = models.CharField(
        _("PyPI Requires Python"), max_length=100, blank=True, null=True
    )
    markers = ArrayField(models.CharField(max_length=100), blank=True, null=True)
    supports_python3 = models.BooleanField(
        _("Supports Python 3"), blank=True, null=True
    )
    participants = models.TextField(
        _("Participants"),
        help_text="List of collaborats/participants on the project",
        blank=True,
    )
    favorite_count = models.IntegerField(
        _("Favorite"), default=0, help_text="Favorite count"
    )
    usage = models.ManyToManyField(User, blank=True)
    created_by = models.ForeignKey(
        User, blank=True, null=True, related_name="creator", on_delete=models.SET_NULL
    )
    last_modified_by = models.ForeignKey(
        User, blank=True, null=True, related_name="modifier", on_delete=models.SET_NULL
    )
    last_fetched = models.DateTimeField(blank=True, null=True, default=now)
    documentation_url = models.URLField(
        _("Documentation URL"), blank=True, null=True, default=""
    )

    commit_list = models.TextField(_("Commit List"), blank=True)
    score = models.IntegerField(_("Score"), default=0)

    date_deprecated = models.DateTimeField(blank=True, null=True)
    date_repo_archived = models.DateTimeField(
        _("date when repo was archived"), blank=True, null=True
    )
    deprecated_by = models.ForeignKey(
        User, blank=True, null=True, related_name="deprecator", on_delete=models.PROTECT
    )
    deprecates_package = models.ForeignKey(
        "self",
        blank=True,
        help_text="The Package that replaces *this* Package",
        null=True,
        on_delete=models.PROTECT,
        related_name="replacement",
    )
    last_exception = models.TextField(blank=True, null=True)
    last_exception_at = models.DateTimeField(blank=True, null=True)
    last_exception_count = models.IntegerField(default=0, blank=True, null=True)

    objects = PackageManager()

    class Meta:
        ordering = ["title"]
        get_latest_by = "id"

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse("package", args=[self.slug])

    def get_opengraph_image_url(self):
        return reverse("package_opengraph", args=[self.slug])

    @property
    def is_deprecated(self):
        return self.date_deprecated is not None

    @property
    def has_favorite(self):
        if self.favorite_count > 0:
            return True
        return False

    def get_pypi_uri(self):
        if self.pypi_name and len(self.pypi_name):
            return f"https://pypi.org/project/{self.pypi_name}/"
        return None

    def get_pypi_json_uri(self):
        if self.pypi_name and len(self.pypi_name):
            return f"https://pypi.org/pypi/{self.pypi_name}/json"
        return None

    @property
    def pypi_name(self):
        """return the pypi name of a package"""

        if not self.pypi_url.strip():
            return ""

        name = self.pypi_url

        if "http://pypi.python.org/pypi/" in name:
            name = name.replace("http://pypi.python.org/pypi/", "")

        if "https://pypi.python.org/pypi/" in name:
            name = name.replace("https://pypi.python.org/pypi/", "")

        if "https://pypi.org/project/" in name:
            name = name.replace("https://pypi.org/project/", "")

        name = name.strip("/")

        return name

    def last_updated(self):
        cache_name = self.cache_namer(self.last_updated)
        last_commit = cache.get(cache_name)
        if last_commit is not None:
            return last_commit
        try:
            last_commit = self.commit_set.latest("commit_date").commit_date
            if last_commit:
                cache.set(cache_name, last_commit)
                return last_commit
        except ObjectDoesNotExist:
            last_commit = None

        return last_commit

    @property
    def repo(self):
        return get_repo_for_repo_url(self.repo_url, self.repo_host or None)

    @property
    def active_examples(self):
        return self.packageexample_set.filter(active=True)

    @property
    def license_latest(self):
        try:
 

# ... (truncated for brevity)
```

## grid/models.py
```python
from django.core.cache import cache
from django.core.cache.utils import make_template_fragment_key
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from core.models import BaseModel
from grid.utils import make_template_fragment_key as grid_make_template_fragment_key
from package.models import Package


class Grid(BaseModel):
    """Grid object, inherits form :class:`package.models.BaseModel`. Attributes:

    * :attr:`~grid.models.Grid.title` - grid title
    * :attr:`~grid.models.Grid.slug` - grid slug for SEO
    * :attr:`~grid.models.Grid.description` - description of the grid
      with line breaks and urlized links
    * :attr:`~grid.models.Grid.is_locked` - boolean field accessible
      to moderators
    * :attr:`~grid.models.Grid.packages` - many-to-many relation
      with :class:~`grid.models.GridPackage` objects
    """

    title = models.CharField(_("Title"), max_length=100)
    slug = models.SlugField(
        _("Slug"), help_text="Slugs will be lowercased", unique=True
    )
    description = models.TextField(
        _("Description"),
        blank=True,
        help_text="Lines are broken and urls are urlized",
        max_length=1000,
    )
    is_locked = models.BooleanField(
        _("Is Locked"), default=False, help_text="Moderators can lock grid access"
    )
    packages = models.ManyToManyField(Package, through="GridPackage")
    header = models.BooleanField(
        _("Header tab?"),
        default=False,
        help_text="If checked then displayed on homepage header",
    )

    def elements(self):
        elements = []
        for feature in self.feature_set.all():
            for element in feature.element_set.all():
                elements.append(element)
        return elements

    def __str__(self):
        return self.title

    @property
    def grid_packages(self):
        """Gets all the packages and orders them for views and other things"""
        gp = self.gridpackage_set.select_related()
        grid_packages = gp.annotate(
            usage_count=models.Count("package__usage")
        ).order_by("-usage_count", "package")
        return grid_packages

    def save(self, *args, **kwargs):
        if self.pk:
            self.grid_packages  # fire the cache
            self.clear_detail_template_cache()  # Delete the template fragment cache
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("grid", args=[self.slug])

    def get_opengraph_image_url(self):
        return reverse("grid_opengraph", args=[self.slug])

    def get_detail_template_cache_key(self):
        return grid_make_template_fragment_key("detail_template_cache", [str(self.pk)])

    def clear_detail_template_cache(self):
        key = self.get_detail_template_cache_key()
        cache.delete(key)

        # delete grid template cache
        template_key = make_template_fragment_key(
            "html_grid_detail_outer", [str(self.pk)]
        )
        cache.delete(template_key)

    class Meta:
        ordering = ["title"]


class GridPackage(BaseModel):
    """Grid package.
    This model describes packages listed on one side of the grids
    and
    explicitly defines the many-to-many relationship between grids
    and the packages
    (i.e - allows any given package to be assigned to several grids at once).

    Attributes:

    * :attr:`grid` - the :class:`~grid.models.Grid` to which the package is assigned
    * :attr:`package` - the :class:`~grid.models.Package`
    """

    grid = models.ForeignKey(Grid, on_delete=models.CASCADE)
    package = models.ForeignKey(Package, on_delete=models.CASCADE)

    class Meta:
        verbose_name = "Grid Package"
        verbose_name_plural = "Grid Packages"

    def save(self, *args, **kwargs):
        self.grid.grid_packages  # fire the cache
        self.grid.clear_detail_template_cache()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.grid.slug} : {self.package.slug}"


class Feature(BaseModel):
    """These are the features measured against a grid.
    ``Feature`` has the following attributes:

    * :attr:`grid` - the grid to which the feature is assigned
    * :attr:`title` - name of the feature (100 chars is max)
    * :attr:`description` - plain-text description
    """

    grid = models.ForeignKey(Grid, on_delete=models.CASCADE)
    title = models.CharField(_("Title"), max_length=100)
    description = models.TextField(_("Description"), blank=True, max_length=1000)

    def save(self, *args, **kwargs):
        self.grid.grid_packages  # fire the cache
        self.grid.clear_detail_template_cache()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.grid.slug} : {self.title}"


help_text = """
Linebreaks are turned into 'br' tags<br />
Urls are turned into links<br />
You can use just 'check', 'yes', 'good' to place a checkmark icon.<br />
You can use 'bad', 'negative', 'evil', 'sucks', 'no' to place a negative icon.<br />
Plus just '+' or '-' signs can be used but cap at 3 multiples to protect layout<br/>

"""


class Element(BaseModel):
    """The individual cells on the grid.
    The ``Element`` grid attributes are:

    * :attr:`grid_package` - foreign key to :class:`~grid.models.GridPackage`
    * :attr:`feature` - foreign key to :class:`~grid.models.Feature`
    * :attr:`text` - the actual contents of the grid cell
    """

    grid_package = models.ForeignKey(GridPackage, on_delete=models.CASCADE)
    feature = models.ForeignKey(Feature, models.CASCADE)
    text = models.TextField(_("text"), blank=True, help_text=help_text, max_length=1000)

    class Meta:
        ordering = ["-id"]

    def save(self, *args, **kwargs):
        self.feature.save()  # fire grid_packages cache
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.grid_package.grid.slug} : {self.grid_package.package.slug} : {self.feature.title}"

```

# Task: Homepage data caching

## Background
The homepage view loads featured packages, grids, and stats on every request.
This causes unnecessary database queries for data that changes infrequently.

## Problem
Looking at `homepage/views.py`, the view queries multiple models without
caching. This impacts homepage load times.

## Task
1. Add caching to homepage featured packages (5 minute cache)
2. Add caching to header grids (5 minute cache)
3. Add caching to homepage stats (total packages, grids, users)
4. Provide cache invalidation when relevant data changes

## Acceptance Criteria
- Homepage queries are reduced on repeated loads
- Cache keys are namespaced properly
- Cache is invalidated when packages/grids are added
- TTL is configurable via settings
- Works with any cache backend (not just memcached)


## Instructions

Add caching to homepage views using Django's cache framework.
Implement cache invalidation on model saves.


## Requirements

1. Make the minimal changes necessary to complete the task
2. Ensure all existing tests continue to pass
3. Follow Django/DRF best practices
4. Add appropriate type hints where applicable
5. Include docstrings for new functions/classes

Provide your solution as code blocks with filepath headers like:
```python
# filepath: package/views.py
...code here...
```
