# Project Structure

```
djangopackages/
├── __init__.py
├── manage.py
├── settings.py
├── urls.py
├── conftest.py
├── apiv3/
│   ├── __init__.py
│   ├── resources.py
│   ├── urls.py
│   └── views.py
├── apiv4/
│   ├── __init__.py
│   ├── admin.py
│   ├── mixins.py
│   ├── serializers.py
│   ├── urls.py
│   └── viewsets.py
├── core/
│   ├── __init__.py
│   ├── models.py
│   └── utils.py
├── grid/
│   ├── __init__.py
│   ├── admin.py
│   ├── forms.py
│   ├── models.py
│   ├── urls.py
│   ├── views.py
│   └── tests/
│       ├── test_views.py
│       └── test_models.py
├── homepage/
│   ├── __init__.py
│   ├── models.py
│   └── views.py
├── package/
│   ├── __init__.py
│   ├── admin.py
│   ├── forms.py
│   ├── managers.py
│   ├── models.py
│   ├── signals.py
│   ├── urls.py
│   ├── utils.py
│   ├── views.py
│   └── tests/
│       ├── test_views.py
│       └── test_models.py
├── profiles/
│   ├── __init__.py
│   └── models.py
├── searchv2/
│   ├── __init__.py
│   ├── models.py
│   ├── utils.py
│   └── views.py
└── templates/
```

# Relevant source files

## apiv4/viewsets.py
```python
from rest_framework import mixins, viewsets
from rest_framework.response import Response

from grid.models import Grid
from package.models import Category, Package
from searchv2.models import SearchV2
from searchv2.views import search_function

from .mixins import MultiLookupFieldMixin
from .serializers import (
    CategorySerializer,
    GridSerializer,
    PackageSerializer,
    SearchV2Serializer,
)


class SearchV2ViewSet(mixins.ListModelMixin, viewsets.GenericViewSet):
    """Accepts a 'q' GET parameter. Results are currently sorted only by
    their weight.
    """

    serializer_class = SearchV2Serializer
    queryset = SearchV2.objects.all()

    def list(self, request):
        qr = request.GET.get("q", "")
        queryset = search_function(qr)[:20]
        serializer = SearchV2Serializer(queryset, many=True)
        return Response(serializer.data)


class PackageViewSet(MultiLookupFieldMixin, viewsets.ReadOnlyModelViewSet):
    """
    API endpoint that allows packages to be viewed or edited.
    """

    queryset = Package.objects.all().order_by("-id")
    serializer_class = PackageSerializer
    paginate_by = 20


class GridViewSet(MultiLookupFieldMixin, viewsets.ReadOnlyModelViewSet):
    queryset = Grid.objects.all().order_by("-id")
    serializer_class = GridSerializer
    paginate_by = 20


class CategoryViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Category.objects.all().order_by("-id")
    serializer_class = CategorySerializer
    paginate_by = 20

```

## apiv4/serializers.py
```python
import emoji
from django.core.exceptions import ImproperlyConfigured
from django.urls import NoReverseMatch
from rest_framework import relations, serializers
from rest_framework.reverse import reverse

from grid.models import Grid
from package.models import Category, Package
from searchv2.models import SearchV2


class GridSerializer(serializers.ModelSerializer):
    packages = serializers.HyperlinkedRelatedField(
        many=True,
        view_name="apiv4:package-detail",
        read_only=True,
        lookup_url_kwarg="pk_or_slug",
    )

    class Meta:
        fields = [
            "id",
            "title",
            "slug",
            "description",
            "is_locked",
            "packages",
            "header",
            "created",
            "modified",
        ]
        model = Grid


class PackageSerializer(serializers.HyperlinkedModelSerializer):
    # 'Source' is attached to the model attribute
    participants = serializers.ListField(source="participant_list")
    commits_over_52 = serializers.ListField(source="commits_over_52_listed")
    grids = serializers.HyperlinkedRelatedField(
        many=True,
        view_name="apiv4:grid-detail",
        read_only=True,
        lookup_url_kwarg="pk_or_slug",
    )
    category = serializers.HyperlinkedRelatedField(
        view_name="apiv4:category-detail", read_only=True
    )

    class Meta:
        model = Package
        fields = (
            "category",
            "grids",
            "id",
            "title",
            "slug",
            "last_updated",
            "last_fetched",
            "repo_url",
            "pypi_version",
            "created",
            "modified",
            "repo_forks",
            "repo_description",
            "pypi_url",
            "documentation_url",
            "repo_watchers",
            "commits_over_52",
            "participants",
        )


class SearchV2Hyperlink(serializers.HyperlinkedRelatedField):
    view_name = "package-detail"

    def get_url(self, obj, view_name, request, format):
        url_kwargs = {"organization_slug": obj.organization.slug, "customer_pk": obj.pk}
        return reverse(view_name, url_kwargs, request=request, format=format)

    def get_object(self, view_name, view_args, view_kwargs):
        lookup_kwargs = {
            "organization__slug": view_kwargs["organization_slug"],
            "pk": view_kwargs["customer_pk"],
        }
        return self.get_queryset().get(**lookup_kwargs)


class HyperlinkFeld(serializers.HyperlinkedRelatedField):
    lookup_field = "pk"

    def get_url(self, obj, view_name):
        """
        Given an object, return the URL that hyperlinks to the object.
        May raise a `NoReverseMatch` if the `view_name` and `lookup_field`
        attributes are not configured to correctly match the URL conf.
        """
        # Unsaved objects will not yet have a valid URL.
        if hasattr(obj, "pk") and obj.pk is None:
            return None
        kwargs = {"pk": 1}
        return reverse(view_name, kwargs=kwargs)

    def to_representation(self, value):
        self.view_name = f"apiv4:{value.item_type}-detail"

        try:
            url = self.get_url(value, self.view_name)
        except NoReverseMatch:
            msg = (
                "Could not resolve URL for hyperlinked relationship using "
                'view name "%s". You may have failed to include the related '
                "model in your API, or incorrectly configured the "
                "`lookup_field` attribute on this field."
            )
            if value in ("", None):
                value_string = {"": "the empty string", None: "None"}[value]
                msg += (
                    " WARNING: The value of the field on the model instance "
                    "was %s, which may be why it didn't match any "
                    "entries in your URL conf." % value_string
                )
            raise ImproperlyConfigured(msg % self.view_name)

        if url is None:
            return None

        return relations.Hyperlink(url, str(value))


class SearchV2Serializer(serializers.ModelSerializer):
    # resource_uri = HyperlinkFeld(source='_self')
    description = serializers.SerializerMethodField()
    title = serializers.SerializerMethodField()

    class Meta:
        model = SearchV2
        exclude = [
            "id",
        ]

    def get_description(self, obj):
        return emoji.emojize(obj.description)

    def get_title(self, obj):
        return emoji.emojize(obj.title)


class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        fields = [
            "id",
            "title",
            "slug",
            "description",
            "title_plural",
            "show_pypi",
            "created",
            "modified",
        ]
        model = Category

```

## apiv4/urls.py
```python
from rest_framework import routers

from .viewsets import CategoryViewSet, GridViewSet, PackageViewSet, SearchV2ViewSet

app_name = "apiv4"

router = routers.DefaultRouter()
router.register(r"packages", PackageViewSet)
router.register(r"search", SearchV2ViewSet)
router.register(r"grids", GridViewSet)
router.register(r"categories", CategoryViewSet)

urlpatterns = router.urls

```

## apiv4/mixins.py
```python
class MultiLookupFieldMixin:
    lookup_url_kwarg = "pk_or_slug"

    @property
    def lookup_field(self):
        assert self.lookup_url_kwarg, "The `lookup_url_kwarg` field is required."

        obj_ident = self.kwargs[self.lookup_url_kwarg]
        return "pk" if obj_ident.isdigit() else "slug"

```

## settings.py
```python
# Django settings
import os.path
import sys
from pathlib import Path

import environ
import sentry_sdk
import structlog
from django.template.defaultfilters import slugify
from sentry_sdk.integrations.django import DjangoIntegration
from sentry_sdk.integrations.redis import RedisIntegration

from core import __version__

env = environ.Env()

BASE_DIR = Path(__file__).parent

PROJECT_ROOT = Path(__file__).parent

DEBUG = env.bool("DJANGO_DEBUG", True)
TEMPLATE_DEBUG = env.bool("TEMPLATE_DEBUG", True)
TEST_MODE = "pytest" in sys.modules

########## CACHE
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": env.str("REDIS_URL"),
    }
}


INTERNAL_IPS = [
    "127.0.0.1",
]

ADMINS = [
    ("Django Packages", "info@djangopackages.org"),
]

MANAGERS = ADMINS

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = "America/New_York"

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = "en-us"

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

USE_TZ = False

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
if DEBUG:
    MEDIA_ROOT = PROJECT_ROOT.joinpath("media")
else:
    MEDIA_ROOT = "/data/media"

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = "/media/"

# Absolute path to the directory that holds static files like app media.
# Example: "/home/media/media.lawrence.com/apps/"
if DEBUG:
    STATIC_ROOT = PROJECT_ROOT.joinpath("collected_static")
else:
    STATIC_ROOT = os.path.join(PROJECT_ROOT, "collected_static")

# URL that handles the static files like app media.
# Example: "http://media.lawrence.com"
STATIC_URL = "/static/"

# Additional directories which hold static files
STATICFILES_DIRS = [
    PROJECT_ROOT.joinpath("static"),
]

HEALTHCHECK = env.bool("HEALTHCHECK", False)
PACKAGE_HEALTHCHECK_URL = env.str("PACKAGE_HEALTHCHECK_URL", "")
PYPI_HEALTHCHECK_URL = env.str("PYPI_HEALTHCHECK_URL", "")
SEARCHV2_HEALTHCHECK_URL = env.str("SEARCHV2_HEALTHCHECK_URL", "")

# Configure Redis
REDIS_HOST = env("REDIS_HOST", default="redis")

# Configure Celery
CELERY_BROKER_URL = f"redis://{REDIS_HOST}:6379"
CELERY_RESULT_BACKEND = f"redis://{REDIS_HOST}:6379"
CELERY_ACCEPT_CONTENT = ["application/json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = "UTC"


# Use the default admin media prefix, which is...
# ADMIN_MEDIA_PREFIX = "/static/admin/"


MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "django_htmx.middleware.HtmxMiddleware",
    "waffle.middleware.WaffleMiddleware",
    "django_structlog.middlewares.RequestMiddleware",
    "maintenance_mode.middleware.MaintenanceModeMiddleware",
]

TEMPLATES = [
    {
        "APP_DIRS": True,
        # See: https://docs.djangoproject.com/en/dev/ref/settings/#std:setting-TEMPLATES-BACKEND
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        # See: https://docs.djangoproject.com/en/dev/ref/settings/#template-dirs
        "DIRS": [
            PROJECT_ROOT.joinpath("templates"),
        ],
        "OPTIONS": {
            # See: https://docs.djangoproject.com/en/dev/ref/settings/#template-debug
            "debug": TEMPLATE_DEBUG,
            # See: https://docs.djangoproject.com/en/dev/ref/settings/#template-loaders
            # See: https://docs.djangoproject.com/en/dev/ref/settings/#template-context-processors
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.template.context_processors.i18n",
                "django.template.context_processors.media",
                "django.template.context_processors.static",
                "django.template.context_processors.tz",
                "django.contrib.messages.context_processors.messages",
                # Your stuff: custom template context processors go here
                "maintenance_mode.context_processors.maintenance_mode",
                "package.context_processors.used_packages_list",
                "grid.context_processors.grid_headers",
                "core.context_processors.current_path",
                "profiles.context_processors.lazy_profile",
                "social_django.context_processors.backends",
                "social_django.context_processors.login_redirect",
                "core.context_processors.core_values",
                "core.context_processors.settings_context",
            ],
        },
    },
]

AUTHENTICATION_BACKENDS = [
    "django.contrib.auth.backends.ModelBackend",
]

PROJECT_APPS = [
    "grid",
    "apiv3",
    "blog",
    "classifiers",
    "core",
    "favorites",
    # "commands",
    "feeds",
    "homepage",
    "package",
    "products",
    "profiles",
    "searchv2",
]

PREREQ_APPS = [
    # Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.sitemaps",
    "django.contrib.sites",
    "django.contrib.messages",
    "django.contrib.humanize",
    "django.contrib.staticfiles",
    # external
    "maintenance_mode",
    "crispy_bootstrap3",
    "crispy_forms",
    "django_better_admin_arrayfield",
    "django_extensions",
    "django_htmx",
    "django_tables2",
    "django_tailwind_cli",
    "heroicons",
    "emojificate",
    "rest_framework",
    "reversion",
    "social_django",
    "waffle",
    "django_q",
    "template_partials",
    "anymail",
    # health checks
    "health_check",
    "health_check.db",
    "health_check.cache",
    # "health_check.storage",
    # "health_check.contrib.redis",
]

INSTALLED_APPS = PREREQ_APPS + PROJECT_APPS

ANYMAIL = {
    "MAILGUN_API_KEY": env.str("MAILGUN_API_KEY", "mail-gun-api-key"),
    "MAILGUN_SENDER_DOMAIN": env.str("MAILGUN_SENDER_DOMAIN", "mail-gun-sender-domain"),
}


# Set the default scheme for forms.URLField to "https"
# TODO: Remove transitional setting in Django 6.0
FORMS_URLFIELD_ASSUME_HTTPS = True

MESSAGE_STORAGE = "django.contrib.messages.storage.session.SessionStorage"

ABSOLUTE_URL_OVERRIDES = {
    "auth.user": lambda o: "/profiles/%s/" % o.username,
}

AUTH_PROFILE_MODULE = "profiles.Profile"

LOGIN_URL = "/auth/login/github/"
LOGIN_REDIRECT_URLNAME = "home"
LOGOUT_REDIRECT_URL = "/"

EMAIL_CONFIRMATION_DAYS = 2
EMAIL_DEBUG = DEBUG

CACHE_TIMEOUT = 60 * 60

ROOT_URLCONF = "urls"

SECRET_KEY = env("SECRET_KEY", default="CHANGEME")

URCHIN_ID = ""

DEFAULT_FROM_EMAIL = "Django Packages <djangopackages-noreply@djangopackages.org>"

if DEBUG:
    EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
    EMAIL_SUBJECT_PREFIX = "[Django Packages] "
else:
    EMAIL_BACKEND = "anymail.backends.mailgun.MailgunBackend"
    EMAIL_SUBJECT_PREFIX = env("EMAIL_SUBJECT_PREFIX", default="[Django Packages] ")

SERVER_EMAIL = "info@djangopackages.org"


EMAIL_SUBJECT_PREFIX = "[Django 

# ... (truncated for brevity)
```

# Task: Consistent API error schema

## Background
All API errors should follow a consistent schema across all endpoints.
This includes validation errors, authentication errors, and server errors.

## Problem
Different endpoints may return errors in different formats. We need a
unified error response format.

## Task
1. Create a custom exception handler for DRF
2. All errors should include: `{"detail": "...", "code": "...", "field": "..." (optional)}`
3. Validation errors should be flattened into a list of field-specific errors
4. Apply to all apiv4 endpoints

## Acceptance Criteria
- 400 validation errors have consistent format with field names
- 401 auth errors include `code: "authentication_required"`
- 403 permission errors include `code: "permission_denied"`
- 404 errors include `code: "not_found"`
- 500 errors include `code: "server_error"` (without exposing internals)


## Instructions

Create a custom DRF exception handler that returns consistent error
responses across all API endpoints.


## Requirements

1. Make the minimal changes necessary to complete the task
2. Ensure all existing tests continue to pass
3. Follow Django/DRF best practices
4. Add appropriate type hints where applicable
5. Include docstrings for new functions/classes

Provide your solution as code blocks with filepath headers like:
```python
# filepath: package/views.py
...code here...
```
