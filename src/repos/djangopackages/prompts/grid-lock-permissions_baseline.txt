# Project Structure

```
djangopackages/
├── __init__.py
├── manage.py
├── settings.py
├── urls.py
├── conftest.py
├── apiv3/
│   ├── __init__.py
│   ├── resources.py
│   ├── urls.py
│   └── views.py
├── apiv4/
│   ├── __init__.py
│   ├── admin.py
│   ├── mixins.py
│   ├── serializers.py
│   ├── urls.py
│   └── viewsets.py
├── core/
│   ├── __init__.py
│   ├── models.py
│   └── utils.py
├── grid/
│   ├── __init__.py
│   ├── admin.py
│   ├── forms.py
│   ├── models.py
│   ├── urls.py
│   ├── views.py
│   └── tests/
│       ├── test_views.py
│       └── test_models.py
├── homepage/
│   ├── __init__.py
│   ├── models.py
│   └── views.py
├── package/
│   ├── __init__.py
│   ├── admin.py
│   ├── forms.py
│   ├── managers.py
│   ├── models.py
│   ├── signals.py
│   ├── urls.py
│   ├── utils.py
│   ├── views.py
│   └── tests/
│       ├── test_views.py
│       └── test_models.py
├── profiles/
│   ├── __init__.py
│   └── models.py
├── searchv2/
│   ├── __init__.py
│   ├── models.py
│   ├── utils.py
│   └── views.py
└── templates/
```

# Relevant source files

## apiv4/viewsets.py
```python
from rest_framework import mixins, viewsets
from rest_framework.response import Response

from grid.models import Grid
from package.models import Category, Package
from searchv2.models import SearchV2
from searchv2.views import search_function

from .mixins import MultiLookupFieldMixin
from .serializers import (
    CategorySerializer,
    GridSerializer,
    PackageSerializer,
    SearchV2Serializer,
)


class SearchV2ViewSet(mixins.ListModelMixin, viewsets.GenericViewSet):
    """Accepts a 'q' GET parameter. Results are currently sorted only by
    their weight.
    """

    serializer_class = SearchV2Serializer
    queryset = SearchV2.objects.all()

    def list(self, request):
        qr = request.GET.get("q", "")
        queryset = search_function(qr)[:20]
        serializer = SearchV2Serializer(queryset, many=True)
        return Response(serializer.data)


class PackageViewSet(MultiLookupFieldMixin, viewsets.ReadOnlyModelViewSet):
    """
    API endpoint that allows packages to be viewed or edited.
    """

    queryset = Package.objects.all().order_by("-id")
    serializer_class = PackageSerializer
    paginate_by = 20


class GridViewSet(MultiLookupFieldMixin, viewsets.ReadOnlyModelViewSet):
    queryset = Grid.objects.all().order_by("-id")
    serializer_class = GridSerializer
    paginate_by = 20


class CategoryViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Category.objects.all().order_by("-id")
    serializer_class = CategorySerializer
    paginate_by = 20

```

## apiv4/serializers.py
```python
import emoji
from django.core.exceptions import ImproperlyConfigured
from django.urls import NoReverseMatch
from rest_framework import relations, serializers
from rest_framework.reverse import reverse

from grid.models import Grid
from package.models import Category, Package
from searchv2.models import SearchV2


class GridSerializer(serializers.ModelSerializer):
    packages = serializers.HyperlinkedRelatedField(
        many=True,
        view_name="apiv4:package-detail",
        read_only=True,
        lookup_url_kwarg="pk_or_slug",
    )

    class Meta:
        fields = [
            "id",
            "title",
            "slug",
            "description",
            "is_locked",
            "packages",
            "header",
            "created",
            "modified",
        ]
        model = Grid


class PackageSerializer(serializers.HyperlinkedModelSerializer):
    # 'Source' is attached to the model attribute
    participants = serializers.ListField(source="participant_list")
    commits_over_52 = serializers.ListField(source="commits_over_52_listed")
    grids = serializers.HyperlinkedRelatedField(
        many=True,
        view_name="apiv4:grid-detail",
        read_only=True,
        lookup_url_kwarg="pk_or_slug",
    )
    category = serializers.HyperlinkedRelatedField(
        view_name="apiv4:category-detail", read_only=True
    )

    class Meta:
        model = Package
        fields = (
            "category",
            "grids",
            "id",
            "title",
            "slug",
            "last_updated",
            "last_fetched",
            "repo_url",
            "pypi_version",
            "created",
            "modified",
            "repo_forks",
            "repo_description",
            "pypi_url",
            "documentation_url",
            "repo_watchers",
            "commits_over_52",
            "participants",
        )


class SearchV2Hyperlink(serializers.HyperlinkedRelatedField):
    view_name = "package-detail"

    def get_url(self, obj, view_name, request, format):
        url_kwargs = {"organization_slug": obj.organization.slug, "customer_pk": obj.pk}
        return reverse(view_name, url_kwargs, request=request, format=format)

    def get_object(self, view_name, view_args, view_kwargs):
        lookup_kwargs = {
            "organization__slug": view_kwargs["organization_slug"],
            "pk": view_kwargs["customer_pk"],
        }
        return self.get_queryset().get(**lookup_kwargs)


class HyperlinkFeld(serializers.HyperlinkedRelatedField):
    lookup_field = "pk"

    def get_url(self, obj, view_name):
        """
        Given an object, return the URL that hyperlinks to the object.
        May raise a `NoReverseMatch` if the `view_name` and `lookup_field`
        attributes are not configured to correctly match the URL conf.
        """
        # Unsaved objects will not yet have a valid URL.
        if hasattr(obj, "pk") and obj.pk is None:
            return None
        kwargs = {"pk": 1}
        return reverse(view_name, kwargs=kwargs)

    def to_representation(self, value):
        self.view_name = f"apiv4:{value.item_type}-detail"

        try:
            url = self.get_url(value, self.view_name)
        except NoReverseMatch:
            msg = (
                "Could not resolve URL for hyperlinked relationship using "
                'view name "%s". You may have failed to include the related '
                "model in your API, or incorrectly configured the "
                "`lookup_field` attribute on this field."
            )
            if value in ("", None):
                value_string = {"": "the empty string", None: "None"}[value]
                msg += (
                    " WARNING: The value of the field on the model instance "
                    "was %s, which may be why it didn't match any "
                    "entries in your URL conf." % value_string
                )
            raise ImproperlyConfigured(msg % self.view_name)

        if url is None:
            return None

        return relations.Hyperlink(url, str(value))


class SearchV2Serializer(serializers.ModelSerializer):
    # resource_uri = HyperlinkFeld(source='_self')
    description = serializers.SerializerMethodField()
    title = serializers.SerializerMethodField()

    class Meta:
        model = SearchV2
        exclude = [
            "id",
        ]

    def get_description(self, obj):
        return emoji.emojize(obj.description)

    def get_title(self, obj):
        return emoji.emojize(obj.title)


class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        fields = [
            "id",
            "title",
            "slug",
            "description",
            "title_plural",
            "show_pypi",
            "created",
            "modified",
        ]
        model = Category

```

## apiv4/urls.py
```python
from rest_framework import routers

from .viewsets import CategoryViewSet, GridViewSet, PackageViewSet, SearchV2ViewSet

app_name = "apiv4"

router = routers.DefaultRouter()
router.register(r"packages", PackageViewSet)
router.register(r"search", SearchV2ViewSet)
router.register(r"grids", GridViewSet)
router.register(r"categories", CategoryViewSet)

urlpatterns = router.urls

```

## apiv4/mixins.py
```python
class MultiLookupFieldMixin:
    lookup_url_kwarg = "pk_or_slug"

    @property
    def lookup_field(self):
        assert self.lookup_url_kwarg, "The `lookup_url_kwarg` field is required."

        obj_ident = self.kwargs[self.lookup_url_kwarg]
        return "pk" if obj_ident.isdigit() else "slug"

```

## grid/views.py
```python
"""views for the :mod:`grid` app"""

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.decorators import login_required, permission_required
from django.db.models import Count, Max, Q
from django.http import Http404, HttpResponseForbidden, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django_tables2 import SingleTableView
from rest_framework.generics import ListAPIView, RetrieveAPIView

from grid.forms import (
    ElementForm,
    FeatureForm,
    GridForm,
    GridPackageFilterForm,
    GridPackageForm,
)
from grid.models import Element, Feature, Grid, GridPackage
from grid.tables import GridTable
from package.forms import PackageForm
from package.models import Package
from package.views import repo_data_for_js


def build_element_map(elements):
    # Horrifying two-level dict due to needing to use hash() function later
    element_map = {}
    for element in elements:
        element_map.setdefault(element.feature_id, {})
        element_map[element.feature_id][element.grid_package_id] = element
    return element_map


class GridListView(SingleTableView):
    table_class = GridTable
    template_name = "grid/grids.html"
    paginate_by = 100

    def get_queryset(self):
        return (
            Grid.objects.filter()
            .annotate(
                # `distinct=True` parameter is required here for multiple annotations to not yield the wrong results
                # See: https://docs.djangoproject.com/en/4.2/topics/db/aggregation/#combining-multiple-aggregations
                gridpackage_count=Count("gridpackage", distinct=True),
                active_gridpackage_count=Count(
                    "gridpackage",
                    filter=Q(
                        gridpackage__package__score__gte=max(
                            0, settings.PACKAGE_SCORE_MIN
                        )
                    ),
                    distinct=True,
                ),
                feature_count=Count("feature", distinct=True),
            )
            .filter(gridpackage_count__gt=0)
            .order_by("-modified", "title")
        )


@login_required
def add_grid(request, template_name="grid/update_grid.html"):
    """Creates a new grid, requires user to be logged in.
    Works for both GET and POST request methods

    Template context:

    * ``form`` - an instance of :class:`~app.grid.forms.GridForm`
    """

    if not request.user.profile.can_add_grid:
        return HttpResponseForbidden("permission denied")

    new_grid = Grid()
    form = GridForm(request.POST or None, instance=new_grid)

    if form.is_valid():
        new_grid = form.save()
        return HttpResponseRedirect(reverse("grid", kwargs={"slug": new_grid.slug}))

    return render(request, template_name, {"form": form})


@login_required
def edit_grid(request, slug, template_name="grid/update_grid.html"):
    """View to modify the grid, handles GET and POST requests.
    This view requires user to be logged in.

    Template context:

    * ``form`` - instance of :class:`grid.forms.GridForm`
    """

    if not request.user.profile.can_edit_grid:
        return HttpResponseForbidden("permission denied")

    grid = get_object_or_404(Grid, slug=slug)
    form = GridForm(request.POST or None, instance=grid)

    if form.is_valid():
        grid = form.save()
        message = "Grid has been edited"
        messages.add_message(request, messages.INFO, message)
        return HttpResponseRedirect(reverse("grid", kwargs={"slug": grid.slug}))
    return render(request, template_name, {"form": form, "grid": grid})


@login_required
def add_feature(request, grid_slug, template_name="grid/update_feature.html"):
    """Adds a feature to the grid, accepts GET and POST requests.

    Requires user to be logged in

    Template context:

    * ``form`` - instance of :class:`grid.forms.FeatureForm` form
    * ``grid`` - instance of :class:`grid.models.Grid` model
    """

    if not request.user.profile.can_add_grid_feature:
        return HttpResponseForbidden("permission denied")

    grid = get_object_or_404(Grid, slug=grid_slug)
    form = FeatureForm(request.POST or None)

    if form.is_valid():
        feature = form.save(commit=False)
        feature.grid = grid
        feature.save()
        return HttpResponseRedirect(reverse("grid", kwargs={"slug": feature.grid.slug}))

    return render(request, template_name, {"form": form, "grid": grid})


@login_required
def edit_feature(request, id, template_name="grid/update_feature.html"):
    """edits feature on a grid - this view has the same
    semantics as :func:`grid.views.add_feature`.

    Requires the user to be logged in.
    """

    if not request.user.profile.can_edit_grid_feature:
        return HttpResponseForbidden("permission denied")

    feature = get_object_or_404(Feature, id=id)
    form = FeatureForm(request.POST or None, instance=feature)

    if form.is_valid():
        feature = form.save()
        return HttpResponseRedirect(reverse("grid", kwargs={"slug": feature.grid.slug}))

    return render(request, template_name, {"form": form, "grid": feature.grid})


@permission_required("grid.delete_feature")
def delete_feature(request, id, template_name="grid/edit_feature.html"):
    # do not need to check permission via profile because
    # we default to being strict about deleting
    """deletes a feature from the grid, ``id`` is id of the
    :class:`grid.models.Feature` model that is to be deleted

    Requires permission `grid.delete_feature`.

    Redirects to the parent :func:`grid.views.grid_detail`
    """

    feature = get_object_or_404(Feature, id=id)
    Element.objects.filter(feature=feature).delete()
    feature.delete()

    return HttpResponseRedirect(reverse("grid", kwargs={"slug": feature.grid.slug}))


@permission_required("grid.delete_gridpackage")
def delete_grid_package(request, id, template_name="grid/edit_feature.html"):
    """Deletes package from the grid, ``id`` is the id of the
    :class:`grid.models.GridPackage` instance

    Requires permission ``grid.delete_gridpackage``.

    Redirects to :func:`grid.views.grid_detail`.
    """

    # do not need to check permission via profile because
    # we default to being strict about deleting
    grid_package = get_object_or_404(GridPackage, id=id)
    grid_package.grid.clear_detail_template_cache()
    Element.objects.filter(grid_package=grid_package).delete()
    grid_package.delete()

    return HttpResponseRedirect(
        reverse("grid", kwargs={"slug": grid_package.grid.slug})
    )


@login_required
def edit_element(
    request, feature_id, package_id, template_name="grid/edit_element.html"
):
    if not request.user.profile.can_edit_grid_element:
        return HttpResponseForbidden("permission denied")

    feature = get_object_or_404(Feature, pk=feature_id)
    grid_package = get_object_or_404(GridPackage, pk=package_id)

    # Sanity check to make sure both the feature and grid_package are related to
    # the same grid!
    if feature.grid_id != grid_package.grid_id:
        raise Http404

    element, created = Element.objects.get_or_create(
        grid_package=grid_package, feature=feature
    )

    form = ElementForm(request.POST or None, instance=element)

    if form.is_valid():
        element = form.save()
        return HttpResponseRedirect(reverse("grid", kwargs={"slug": feature.grid.slug}))

    return render(
        request,
        template_name,
        {
            "form": form,
            "feature": feature,
            "package": grid_package.package,
            "grid": feature.grid,
        },
    )


@login_required
def add_grid_package(request, grid_slug, template_name="grid/add_grid_package.html"):
    """Add an existing package to this grid."""

    if not request.user.profile.can_add_grid_package:
        return HttpResponseForbidden("permission denied")

    grid = get_object_or_4

# ... (truncated for brevity)
```

## grid/models.py
```python
from django.core.cache import cache
from django.core.cache.utils import make_template_fragment_key
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from core.models import BaseModel
from grid.utils import make_template_fragment_key as grid_make_template_fragment_key
from package.models import Package


class Grid(BaseModel):
    """Grid object, inherits form :class:`package.models.BaseModel`. Attributes:

    * :attr:`~grid.models.Grid.title` - grid title
    * :attr:`~grid.models.Grid.slug` - grid slug for SEO
    * :attr:`~grid.models.Grid.description` - description of the grid
      with line breaks and urlized links
    * :attr:`~grid.models.Grid.is_locked` - boolean field accessible
      to moderators
    * :attr:`~grid.models.Grid.packages` - many-to-many relation
      with :class:~`grid.models.GridPackage` objects
    """

    title = models.CharField(_("Title"), max_length=100)
    slug = models.SlugField(
        _("Slug"), help_text="Slugs will be lowercased", unique=True
    )
    description = models.TextField(
        _("Description"),
        blank=True,
        help_text="Lines are broken and urls are urlized",
        max_length=1000,
    )
    is_locked = models.BooleanField(
        _("Is Locked"), default=False, help_text="Moderators can lock grid access"
    )
    packages = models.ManyToManyField(Package, through="GridPackage")
    header = models.BooleanField(
        _("Header tab?"),
        default=False,
        help_text="If checked then displayed on homepage header",
    )

    def elements(self):
        elements = []
        for feature in self.feature_set.all():
            for element in feature.element_set.all():
                elements.append(element)
        return elements

    def __str__(self):
        return self.title

    @property
    def grid_packages(self):
        """Gets all the packages and orders them for views and other things"""
        gp = self.gridpackage_set.select_related()
        grid_packages = gp.annotate(
            usage_count=models.Count("package__usage")
        ).order_by("-usage_count", "package")
        return grid_packages

    def save(self, *args, **kwargs):
        if self.pk:
            self.grid_packages  # fire the cache
            self.clear_detail_template_cache()  # Delete the template fragment cache
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("grid", args=[self.slug])

    def get_opengraph_image_url(self):
        return reverse("grid_opengraph", args=[self.slug])

    def get_detail_template_cache_key(self):
        return grid_make_template_fragment_key("detail_template_cache", [str(self.pk)])

    def clear_detail_template_cache(self):
        key = self.get_detail_template_cache_key()
        cache.delete(key)

        # delete grid template cache
        template_key = make_template_fragment_key(
            "html_grid_detail_outer", [str(self.pk)]
        )
        cache.delete(template_key)

    class Meta:
        ordering = ["title"]


class GridPackage(BaseModel):
    """Grid package.
    This model describes packages listed on one side of the grids
    and
    explicitly defines the many-to-many relationship between grids
    and the packages
    (i.e - allows any given package to be assigned to several grids at once).

    Attributes:

    * :attr:`grid` - the :class:`~grid.models.Grid` to which the package is assigned
    * :attr:`package` - the :class:`~grid.models.Package`
    """

    grid = models.ForeignKey(Grid, on_delete=models.CASCADE)
    package = models.ForeignKey(Package, on_delete=models.CASCADE)

    class Meta:
        verbose_name = "Grid Package"
        verbose_name_plural = "Grid Packages"

    def save(self, *args, **kwargs):
        self.grid.grid_packages  # fire the cache
        self.grid.clear_detail_template_cache()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.grid.slug} : {self.package.slug}"


class Feature(BaseModel):
    """These are the features measured against a grid.
    ``Feature`` has the following attributes:

    * :attr:`grid` - the grid to which the feature is assigned
    * :attr:`title` - name of the feature (100 chars is max)
    * :attr:`description` - plain-text description
    """

    grid = models.ForeignKey(Grid, on_delete=models.CASCADE)
    title = models.CharField(_("Title"), max_length=100)
    description = models.TextField(_("Description"), blank=True, max_length=1000)

    def save(self, *args, **kwargs):
        self.grid.grid_packages  # fire the cache
        self.grid.clear_detail_template_cache()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.grid.slug} : {self.title}"


help_text = """
Linebreaks are turned into 'br' tags<br />
Urls are turned into links<br />
You can use just 'check', 'yes', 'good' to place a checkmark icon.<br />
You can use 'bad', 'negative', 'evil', 'sucks', 'no' to place a negative icon.<br />
Plus just '+' or '-' signs can be used but cap at 3 multiples to protect layout<br/>

"""


class Element(BaseModel):
    """The individual cells on the grid.
    The ``Element`` grid attributes are:

    * :attr:`grid_package` - foreign key to :class:`~grid.models.GridPackage`
    * :attr:`feature` - foreign key to :class:`~grid.models.Feature`
    * :attr:`text` - the actual contents of the grid cell
    """

    grid_package = models.ForeignKey(GridPackage, on_delete=models.CASCADE)
    feature = models.ForeignKey(Feature, models.CASCADE)
    text = models.TextField(_("text"), blank=True, help_text=help_text, max_length=1000)

    class Meta:
        ordering = ["-id"]

    def save(self, *args, **kwargs):
        self.feature.save()  # fire grid_packages cache
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.grid_package.grid.slug} : {self.grid_package.package.slug} : {self.feature.title}"

```

# Task: Grid lock permission enforcement

## Background
Grids have an `is_locked` field that should prevent non-moderators from editing.
However, this check may not be consistently enforced across all grid-related views.

## Problem
In `grid/views.py`, the lock status should be checked before allowing:
- Adding/removing packages from a grid
- Editing grid features and elements
- Modifying grid metadata

## Task
1. Create a `@require_unlocked_grid` decorator or mixin
2. Return 403 with `{"detail": "Grid is locked", "code": "grid_locked"}` 
3. Allow moderators (is_staff or specific permission) to bypass lock
4. Apply to all grid modification views

## Acceptance Criteria
- Locked grids cannot be modified by regular users
- Moderators can modify locked grids
- Proper JSON error responses with status codes
- All existing grid tests pass


## Instructions

Enforce the grid lock status in all grid modification views.
Return proper error responses when locked grids are modified.


## Requirements

1. Make the minimal changes necessary to complete the task
2. Ensure all existing tests continue to pass
3. Follow Django/DRF best practices
4. Add appropriate type hints where applicable
5. Include docstrings for new functions/classes

Provide your solution as code blocks with filepath headers like:
```python
# filepath: package/views.py
...code here...
```
